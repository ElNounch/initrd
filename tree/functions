# -*- shell-script -*-


## Logging functions

_log_msg() {
    printf "${@}"
}
log_success_msg() {
    _log_msg "Success: ${@}."
}
log_failure_msg() {
    _log_msg "Failure: ${@}."
}
log_warning_msg() {
    _log_msg "Warning: ${@}."
}
log_begin_msg() {
    _log_msg "Begin: ${@} ... "
}
log_end_msg() {
    _log_msg " done.\n"
}
log_fatal_msg() {
    _log_msg "Fatal: ${@}\n"
    sleep 5
    reboot
}

## OCS specifics

# Signal to OCS the current server state
signal_state() {
    state="${1}"
    RETRIES=30
    METADATA_PORT=80
    SLEEP_BETWEEN_RETRIES=1

    retries=0
    while [ "${retries}" -lt "${RETRIES}" ]; do
        log_begin_msg "Signaling the server is ${state} to the control plane"
        has_opt nometadata || \
            http_patch "${METADATA_IP}" "${METADATA_PORT}" "{\"state_detail\": \"${state}\"}"
        if [ ${?} -eq 0 ]; then
            log_success_msg "control plane is aware that server is ${state}"
	    log_end_msg
            return
        else
            log_failure_msg "unable to signal server is ${state}"
	    log_end_msg
        fi

        retries=$((${retries}+1))
        test ${retries} -eq ${RETRIES} || sleep ${SLEEP_BETWEEN_RETRIES}
    done

    log_failure_msg "unable to signal state=$state after ${RETRIES} attempts, continuing boot.."
    log_end_msg
}


## Helpers

# There is no option to send a patch with wget in busybox
http_patch() {
    metadata_ip="${1}"
    metadata_port="${2}"
    content="${3}"
    content_length=$(echo -n "${content}" | wc -c)
    patch_body="PATCH /state HTTP/1.1
User-Agent: ocs-http-patch/0.1.0
Host: ${metadata_ip}:${metadata_port}
Accept: */*
content-type: application/json
Content-Length: ${content_length}

${content}"

    ( echo -n "${patch_body}" && sleep 1 ) \
        | nc "${metadata_ip}" "${metadata_port}" | grep '200 OK' >/dev/null
}


resolve_hostnames() {
    sed "s/metadata.local/${METADATA_IP}/g"
}


# Function for parsing command line options with "=" in them
get_opt() {
    key=$1
    default=$2
    ret=$(cat /proc/cmdline | tr " " "\n" | grep "^$1" | cut -d "=" -f 2)
    if [ -z "$ret" ]; then
        echo "$default" | resolve_hostnames
    else
        echo "$ret"| resolve_hostnames
    fi
}

has_opt() {
    cat /proc/cmdline | tr " " "\n" | grep "^$1\$" >/dev/null
}

get_metadata() {
    for idx in $(seq -w 0 $(oc-metadata --cached TAGS)); do
	tag=$(oc-metadata --cached TAGS_$idx)
	if [ $(echo "$tag" | grep "^$1=") ]; then
	    echo $tag | sed 's/^[^=]*=//' | resolve_hostnames
	    return
	fi
    done
}

has_metadata() {
    (
	for idx in $(seq -w 0 $(oc-metadata --cached TAGS)); do
	    oc-metadata --cached TAGS_$idx
	done
    ) | grep "^$1\$" >/dev/null
}

get_any() {
    key=$1
    default=${2:-""}

    ret=$(get_metadata $key)
    if [ -n "$ret" ]; then
	echo "$ret"
    else
	get_opt "$key" "$default"
    fi
}
